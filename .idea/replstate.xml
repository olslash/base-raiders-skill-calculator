<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1442818444937">{:repl-history {:ide [], :local [&quot;(q)&quot; &quot;(print q)&quot; &quot;graph&quot; &quot;(def q #queue [1 2 3])&quot; &quot;(conj q 4)&quot; &quot;(skills {:resist-damage  {:stress-cap 1}\n             :stress-cap     {:physical-force 2}\n             :physical-force {:climb 1 :leap 1}\n             :climb          {:move 1}\n             :leap           {:move 1 :physical-force :1}\n             :move           {:dodge 0 :stealth :2}\n             :dodge          {:move 0}\n             :stealth        {:move 2 :dexterity 1}\n             :dexterity      {:stealth 1 :security 1 :strike 2}\n             :strike         {:parry 0 :dexterity 2}})&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (loop [queue (#queue [from])\n         visited (hash-set from)\n         node (peek queue)\n         current-path []]\n    node))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (loop [queue (#queue [from])\n         visited (hash-set from)\n         \n         current-path []]\n    node))&quot; &quot;(move-cost skills :climb :move)&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (let [queue (#queue [from])\n         visited (hash-set from)\n         node (peek queue)\n         current-path []]\n    node))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (let [a 5]\n    a))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (let [queue (#queue [from])\n         ]\n    queue))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (let [q (#queue [from])\n         ]\n    q))&quot; &quot;(def q (#queue [:lol]))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (let [queue #queue [from]\n         visited (hash-set from)\n         node (peek queue)\n         current-path []]\n    node))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (loop [queue #queue [from]\n        visited      (hash-set from)\n        node         (peek queue)\n        current-path []]\n    node))&quot; &quot;(conj q [1 2 3])&quot; &quot;(conj q 1 2 3)&quot; &quot;(peek (pop [1 2 3]))&quot; &quot;(neighbors skills :climb)&quot; &quot;(into [] (neighbors skills :move))&quot; &quot;(keys (neighbors skills :move))&quot; &quot;(def q #queue [])&quot; &quot;(conj q [:dodge :stelath])&quot; &quot;(apply conj q [:dodge :stelath])&quot; &quot;(apply conj q (vec (keys (neighbors skills :leap))))&quot; &quot;#(1 2 3)&quot; &quot;#{1 2 3}&quot; &quot;(filter #{1 2 3} 3) &quot; &quot;(filter #{:a :b :c} :a) &quot; &quot;(filter :a #{:a :b :c}) &quot; &quot;(filter [:a] #{:a :b :c}) &quot; &quot;(filter #{:a :b :c} [:a]) &quot; &quot;(filter #{:a :b :c} [:a :b :e]) &quot; &quot;(filter (not #{:a :b :c}) [:a :b :e]) &quot; &quot;(filter #(not #{:a :b :c} %) [:a :b :e]) &quot; &quot;(filter #(not (#{:a :b :c} %)) [:a :b :e]) &quot; &quot;(vec (keys (filter #(not (#{:a :b} %))\n                   [:b :c])))&quot; &quot;(filter #(not (#{:a :b} %))\n        (vec (keys [:b :c])))&quot; &quot;(filter #(not (#{:a :b} %))\n        (vec (keys {:b 1 :c 1})))&quot; &quot;(def queue #queue [])&quot; &quot;(apply conj queue (filter #(not (#{:a} %))\n                          (vec (keys {:a 1 :b 2 :c 3}))))&quot; &quot;(def queue #queue [:a :e])&quot; &quot;(apply conj queue (filter #(not (#{:a :e} %))\n                          (vec (keys {:a 1 :b 2 :c 3}))))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (loop [queue #queue [from]\n        visited       (hash-set from)\n        node          (peek queue)\n        path          []]\n    (if (= node to)\n      (conj path to)\n      (recur (apply conj queue (filter #(not (visited %))\n                                       (vec (keys (neighbors net node)))))\n             ; filter keys by their membership in visited\n             (conj visited node)\n             (peek (pop queue))\n             (conj path node)))))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes in the form [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (loop [queue #queue [from]\n        visited       (hash-set from)\n        node          (peek queue)\n        path          []]\n    (if (= node to)\n      (conj path to)\n      (recur (apply conj queue (filter #(not (visited %))\n                                       (vec (keys (neighbors net node)))))\n             ; filter keys by their membership in visited\n             (conj visited node)\n             []\n             (conj path node)))))&quot; &quot;(peek #queue [])&quot; &quot;(or (peek (pop #queue [])) #queue [])&quot; &quot;(#{} :a)&quot; &quot;(conj nil #{})&quot; &quot;(conj :a #{})&quot; &quot;(conj #{} nil)&quot; &quot;(conj #{nil} nil)&quot; &quot;(keys nil)&quot; &quot;(vec (keys nil))&quot; &quot;(empty? #queue [])&quot; &quot;(pop #queue [])&quot; &quot;(def skills {:resist-damage  {:stress-cap 1}\n             :stress-cap     {:physical-force 2}\n             :physical-force {:climb 1 :leap 1}\n             :climb          {:move 1}\n             :leap           {:move 1 :physical-force :1}\n             :move           {:dodge 0 :stealth :2}\n             :dodge          {:move 0}\n             :stealth        {:move 2 :dexterity 1}\n             :dexterity      {:stealth 1 :security 1 :strike 2}\n             :strike         {:parry 0 :dexterity 2}})&quot; &quot;(defn neighbors [net node]\n  \&quot;the neighbors of a node\&quot;\n  (node net))&quot; &quot;(defn move-cost [net from to]\n  \&quot;the cost to move from a node to one of its neighbors\&quot;\n  (if (= from to) 0\n    (let [neighbors (neighbors net from)]\n      (to neighbors))))&quot; &quot;(defn path [net from to]\n  \&quot;finds a path between two nodes as a vector like [:a :b: :c].\n  In the dataset, all paths from one node to another are equal length,\n  so no need to do a shortest-path algorithm\&quot;\n  (loop [queue         #queue [from]\n         visited       (hash-set from)\n         path          []]\n    (do\n      (print queue)\n      (print visited)\n      (print path)\n\n      (let [; dequeue a node\n            node (peek queue)\n            ; enqueue node's unvisited neighbors\n            neighbor-keys (vec (keys (neighbors net node)))\n            queue-with-unvisited-neighbors (apply conj\n                                                  (pop queue)\n                                                  (filter #(not (visited %))\n                                     neighbor-keys))\n            ; mark node as visited\n            new-visited (conj visited node)\n            ; add node to path\n            current-path (conj path node)]\n        (cond\n          (empty? queue) nil                                ; not connected\n          (= node to) (current-path)                        ; found\n          :else (recur queue-with-unvisited-neighbors\n                       new-visited\n                       current-path))))))&quot; &quot;(vec (keys (neighbors net :move)))&quot; &quot;(vec (keys (neighbors graph :move)))&quot; &quot;(vec (keys (neighbors skills :move)))&quot; &quot;(let ns (vec (keys (neighbors skills :move))))&quot; &quot;(def ns (vec (keys (neighbors skills :move))))&quot; &quot;ns&quot; &quot;(apply conj #queue [] (filter #(not (#{} %)) ns))&quot; &quot;(apply conj #queue [] (filter #(not (#{:dodge} %)) ns))&quot; &quot;q&quot; &quot;(def q #queue[])&quot; &quot;(def q #queue[:a])&quot; &quot;(peek )&quot; &quot;(peek q)&quot; &quot;(pop q)&quot; &quot;(def a 12)&quot; &quot;(def a (+ a 12))&quot; &quot;a&quot; &quot;(path)&quot; &quot;(path skills :climb :move)&quot; &quot;(into #{} [1 2 3])&quot; &quot;(ns base-raiders.graph)&quot; &quot;(neighbors graph :physical-force)&quot; &quot;(into [] (neighbors skills :physical-force))&quot; &quot;(neighbors skills :physical-force)&quot; &quot;(conj [1 2 3] [4 5 6])&quot; &quot;(into [1 2 3] [4 5 6])&quot; &quot;(remove [1 2] [1 2 3 4 5])&quot; &quot;(remove  [1 2 3 4 5] [1 2])&quot; &quot;(remove  [ 2 3 4 5] [1 2])&quot; &quot;#{(neighbors graph :strike)}&quot; &quot;#{(neighbors skills :strike)}&quot; &quot;(into #{} (neighbors skills :strike))&quot; &quot;(pop #{:a :B})&quot; &quot;(first #{:a :B})&quot; &quot;(rest #{:a :B})&quot; &quot;(remove #{:a} [:a :b :c])&quot; &quot;(pop (remove #{:a} [:a :b :c]))&quot; &quot;(path-between skills :move :dodge)&quot; &quot;(neighbors skills :move)&quot; &quot;(path-between skills :move :move)&quot;], :remote []}}</component>
</project>